hello world

array(['AAPL', 'ADI', 'AMD', 'AMZN', 'GOOGL', 'HPQ', 'LENOVO', 'META',
       'MRVL', 'MSFT', 'MU', 'NVDA', 'ORCL', 'QCOM', 'SKHYNIX', 'TSM',
       'WDC'], dtype=object)

X= pd.DataFrame()
X['date'] = data['TDATE'][(data['TDATE']>=pd.to_datetime('2011-01-01')) & (data['TICKER'] == 'WDC')]
for tick in np.unique(data['TICKER']):
    temp = pd.DataFrame({'date':data['TDATE'][(data['TDATE']>=pd.to_datetime('2011-01-01')) & (data['TICKER'] == tick)],
                         tick:data['PX_LAST'][(data['TDATE']>=pd.to_datetime('2011-01-01')) & (data['TICKER'] == tick)],
                         #tick+'_CAP':data['CUR_MKT_CAP'][(data['TDATE']>=pd.to_datetime('2011-01-01')) & (data['TICKER'] == tick)]
                        })
    X = X.merge(temp,how='left',on='date')
X['META'].fillna(method='bfill',inplace=True)
df = pd.DataFrame()
for tick in ['AAPL', 'ADI', 'AMD', 'AMZN', 'GOOGL', 'HPQ', 'LENOVO', 'META',
       'MRVL', 'MSFT', 'MU', 'NVDA', 'ORCL', 'QCOM', 'SKHYNIX', 'TSM', 'WDC']:
    df[tick+'_3'] = X[tick]/X[tick].shift(3) - 1
    df[tick+'_rol6'] = X[tick]/X[tick].rolling(6).mean() - 1
    df[tick+'_rol12'] = X[tick]/X[tick].rolling(12).mean() - 1
df.index = X['date']
for tick in df.columns:
    df[tick+'_L1'] = df[tick].shift(1)
    df[tick+'_L2'] = df[tick].shift(2)
    df[tick+'_L3'] = df[tick].shift(3)
    df[tick+'_L4'] = df[tick].shift(4)
    df[tick+'_L5'] = df[tick].shift(5)
    df[tick+'_L6'] = df[tick].shift(6)

y = dd['y_TTL']/dd['y_TTL'].shift(3) -1 
df['y'] = y.values
df = df.dropna()
y = df['y']
df.drop('y',axis=1,inplace=True)

from hyppo.independence import MGC
l = []
for i in range(df.shape[1]):
    for j in range(i+1,df.shape[1]):
        if np.corrcoef(df.iloc[:,i],df.iloc[:,j])[0,1] > 0.75:
            temp=[]
            result = MGC().test(x=df.iloc[:-3,i].values.reshape(-1,1), y=np.array(y.iloc[3:]).reshape(-1,1),reps=200)
            temp.append(result.stat)
            result = MGC().test(x=df.iloc[:-3,j].values.reshape(-1,1), y=np.array(y.iloc[3:]).reshape(-1,1),reps=200)
            temp.append(result.stat)
            if temp[0]>temp[1]:
                print([df.columns[i],df.columns[j]])
                l.append(df.columns[j])
            else:
                print([df.columns[j],df.columns[i]])
                l.append(df.columns[i])

from sklearn.ensemble import RandomForestRegressor
m = RandomForestRegressor(n_estimators=500,max_depth=3,max_features='sqrt')
df.drop(list(set(l)),axis=1,inplace=True)
df.shape
df_future = df.iloc[-3:]
df = df.shift(3)
df.dropna(inplace=True)
y = y.iloc[3:]
weights = {}
for year in range(df.index[0].year+4,df.index[-1].year):
    m.fit(df[(df.index > pd.to_datetime(str(year-4)+'-01-01')) & (df.index <= pd.to_datetime(str(year)+'-12-31'))],
      y[(y.index > pd.to_datetime(str(year-4)+'-01-01')) & (y.index <= pd.to_datetime(str(year)+'-12-31'))])
    weights[year] = m.feature_importances_
temp = []
for i in range(df.shape[0]):
    if df.index[i].year <=list(weights.keys())[0] + 1:
        temp.append(np.sum(df.iloc[i].values * weights[list(weights.keys())[0]]))
    else:
        temp.append(np.sum(df.iloc[i].values * weights[df.index[i].year - 1]))
df['composite'] = temp    
temp = []
for i in range(df_future.shape[0]):
    if df_future.index[i].year <=list(weights.keys())[0] + 1:
        temp.append(np.sum(df_future.iloc[i].values * weights[list(weights.keys())[0]]))
    else:
        temp.append(np.sum(df_future.iloc[i].values * weights[max(list(weights.keys()))]))
df_future['composite'] = temp  
df.composite.plot()

import effector
pdp = effector.PDP(
    df[(df.index > pd.to_datetime('2020-12-31')) & (df.index <= pd.to_datetime('2025-12-31'))].values,  # Use the test set as background data
    m.predict,  # Prediction function
    feature_names=df.columns,  # (optional) Feature names
    #target_name=bike_sharing.target_name  # (optional) Target variable name
)
pdp.plot(
    feature=34
)
